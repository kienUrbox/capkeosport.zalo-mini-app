var w=Object.defineProperty,L=Object.defineProperties;var y=Object.getOwnPropertyDescriptors;var m=Object.getOwnPropertySymbols;var R=Object.prototype.hasOwnProperty,S=Object.prototype.propertyIsEnumerable;var C=(r,t,a)=>t in r?w(r,t,{enumerable:!0,configurable:!0,writable:!0,value:a}):r[t]=a,c=(r,t)=>{for(var a in t||(t={}))R.call(t,a)&&C(r,a,t[a]);if(m)for(var a of m(t))S.call(t,a)&&C(r,a,t[a]);return r},g=(r,t)=>L(r,y(t));var p=(r,t)=>()=>(t||r((t={exports:{}}).exports,t),t.exports);var l=(r,t,a)=>new Promise((e,i)=>{var n=d=>{try{s(a.next(d))}catch(u){i(u)}},o=d=>{try{s(a.throw(d))}catch(u){i(u)}},s=d=>d.done?e(d.value):Promise.resolve(d.value).then(n,o);s((a=a.apply(r,t)).next())});import{c as N,a as h}from"./index.CAfnB7xe.module.js";var k=p(f=>{N((r,t)=>({notifications:[],stats:null,unreadCount:0,isLoading:!1,isStatsLoading:!1,error:null,setNotifications:a=>r({notifications:a,unreadCount:a.filter(e=>!e.isRead).length}),setStats:a=>r({stats:a,unreadCount:a.unread}),addNotification:a=>r(e=>({notifications:[a,...e.notifications],unreadCount:e.unreadCount+(a.isRead?0:1)})),updateNotification:(a,e)=>r(i=>{var n,o;return{notifications:i.notifications.map(s=>s.id===a?c(c({},s),e):s),unreadCount:e.isRead!==void 0?(n=i.notifications.find(s=>s.id===a))!=null&&n.isRead&&!e.isRead?i.unreadCount+1:!((o=i.notifications.find(s=>s.id===a))!=null&&o.isRead)&&e.isRead?i.unreadCount-1:i.unreadCount:i.unreadCount}}),removeNotification:a=>r(e=>{var i;return{notifications:e.notifications.filter(n=>n.id!==a),unreadCount:(i=e.notifications.find(n=>n.id===a))!=null&&i.isRead?e.unreadCount:e.unreadCount-1}}),clearError:()=>r({error:null}),setError:a=>r({error:a}),fetchNotifications:a=>l(f,null,function*(){var e,i;try{const n=t();if(n.isLoading)return console.log("[NotificationStore] Skipping fetch - already loading"),n.notifications;r({isLoading:!0,error:null});const o=yield h.get("/notifications",a);if(o.success&&o.data){let s=[],d=0;return Array.isArray(o.data)?(s=o.data,d=s.filter(u=>!u.isRead).length):(s=o.data.items||[],d=o.data.unread||s.filter(u=>!u.isRead).length),r({notifications:s,unreadCount:d,error:null}),s}else throw new Error(((e=o.error)==null?void 0:e.message)||"Failed to fetch notifications")}catch(n){const o=((i=n.error)==null?void 0:i.message)||n.message||"Không thể tải thông báo";throw r({error:o,isLoading:!1}),n}finally{r({isLoading:!1})}}),markAsRead:a=>l(f,null,function*(){var e,i;try{r({isLoading:!0,error:null});const n=yield h.patch(`/notifications/${a}/read`);if(n.success&&n.data){t().updateNotification(a,{isRead:!0});const o=t();o.stats&&r({stats:g(c({},o.stats),{unread:Math.max(0,o.stats.unread-1)}),unreadCount:Math.max(0,o.unreadCount-1)})}else throw new Error(((e=n.error)==null?void 0:e.message)||"Failed to mark as read")}catch(n){const o=((i=n.error)==null?void 0:i.message)||n.message||"Không thể đánh dấu đã đọc";throw r({error:o,isLoading:!1}),n}finally{r({isLoading:!1})}}),markAllAsRead:()=>l(f,null,function*(){var a,e;try{r({isLoading:!0,error:null});const i=yield h.post("/notifications/read-all");if(i.success){r(o=>({notifications:o.notifications.map(s=>g(c({},s),{isRead:!0})),unreadCount:0}));const n=t();n.stats&&r({stats:g(c({},n.stats),{unread:0})})}else throw new Error(((a=i.error)==null?void 0:a.message)||"Failed to mark all as read")}catch(i){const n=((e=i.error)==null?void 0:e.message)||i.message||"Không thể đánh dấu tất cả đã đọc";throw r({error:n,isLoading:!1}),i}finally{r({isLoading:!1})}}),fetchStats:()=>l(f,null,function*(){var a,e;try{const i=t();if(i.isStatsLoading)return i.stats;r({isStatsLoading:!0,error:null});const n=yield h.get("/notifications/stats");if(n.success&&n.data)return r({stats:n.data,unreadCount:n.data.unread,error:null}),n.data;throw new Error(((a=n.error)==null?void 0:a.message)||"Failed to fetch stats")}catch(i){const n=((e=i.error)==null?void 0:e.message)||i.message||"Không thể tải thống kê";throw r({error:n,isStatsLoading:!1}),i}finally{r({isStatsLoading:!1})}})}))});export default k();
