var C=Object.defineProperty,R=Object.defineProperties;var m=Object.getOwnPropertyDescriptors;var y=Object.getOwnPropertySymbols;var w=Object.prototype.hasOwnProperty,L=Object.prototype.propertyIsEnumerable;var S=(t,s,o)=>s in t?C(t,s,{enumerable:!0,configurable:!0,writable:!0,value:o}):t[s]=o,l=(t,s)=>{for(var o in s||(s={}))w.call(s,o)&&S(t,o,s[o]);if(y)for(var o of y(s))L.call(s,o)&&S(t,o,s[o]);return t},u=(t,s)=>R(t,m(s));var f=(t,s,o)=>new Promise((r,e)=>{var i=d=>{try{a(o.next(d))}catch(c){e(c)}},n=d=>{try{a(o.throw(d))}catch(c){e(c)}},a=d=>d.done?r(d.value):Promise.resolve(d.value).then(i,n);a((o=o.apply(t,s)).next())});import{c as A,a as g}from"./index.BJg0ZeP9.module.js";const h=A((t,s)=>({notifications:[],stats:null,unreadCount:0,isLoading:!1,isStatsLoading:!1,error:null,setNotifications:o=>t({notifications:o,unreadCount:o.filter(r=>!r.isRead).length}),setStats:o=>t({stats:o,unreadCount:o.unread}),addNotification:o=>t(r=>({notifications:[o,...r.notifications],unreadCount:r.unreadCount+(o.isRead?0:1)})),updateNotification:(o,r)=>t(e=>{var i,n;return{notifications:e.notifications.map(a=>a.id===o?l(l({},a),r):a),unreadCount:r.isRead!==void 0?(i=e.notifications.find(a=>a.id===o))!=null&&i.isRead&&!r.isRead?e.unreadCount+1:!((n=e.notifications.find(a=>a.id===o))!=null&&n.isRead)&&r.isRead?e.unreadCount-1:e.unreadCount:e.unreadCount}}),removeNotification:o=>t(r=>{var e;return{notifications:r.notifications.filter(i=>i.id!==o),unreadCount:(e=r.notifications.find(i=>i.id===o))!=null&&e.isRead?r.unreadCount:r.unreadCount-1}}),clearError:()=>t({error:null}),setError:o=>t({error:o}),fetchNotifications:o=>f(void 0,null,function*(){var r,e;try{const i=s();if(i.isLoading)return console.log("[NotificationStore] Skipping fetch - already loading"),i.notifications;t({isLoading:!0,error:null}),console.log("[NotificationStore] ðŸ“¥ Fetching notifications with params:",o);const n=yield g.get("/notifications",{params:o});if(console.log("[NotificationStore] ðŸ“¬ API response:",n),n.success&&n.data){let a=[],d=0;if(Array.isArray(n.data)?(a=n.data,d=a.filter(c=>!c.isRead).length):"notifications"in n.data?(a=n.data.notifications||[],d=n.data.unreadCount||a.filter(c=>!c.isRead).length):(a=n.data.items||[],d=n.data.unread||a.filter(c=>!c.isRead).length),console.log("[NotificationStore] ðŸ“Š Raw notifications:",a.length),console.log("[NotificationStore] ðŸ” First notification:",a[0]),o!=null&&o.type){const c=a.length;a=a.filter(N=>N.type===o.type),console.log("[NotificationStore] ðŸŽ¯ Filtered by type:",o.type,"from",c,"to",a.length)}if(o!=null&&o.unreadOnly){const c=a.length;a=a.filter(N=>!N.isRead),console.log("[NotificationStore] ðŸ“­ Filtered unread only: from",c,"to",a.length)}return t({notifications:a,unreadCount:d,error:null}),a}else throw new Error(((r=n.error)==null?void 0:r.message)||"Failed to fetch notifications")}catch(i){const n=((e=i.error)==null?void 0:e.message)||i.message||"KhÃ´ng thá»ƒ táº£i thÃ´ng bÃ¡o";throw t({error:n,isLoading:!1}),i}finally{t({isLoading:!1})}}),markAsRead:o=>f(void 0,null,function*(){var r,e;try{t({isLoading:!0,error:null});const i=yield g.patch(`/notifications/${o}/read`);if(i.success&&i.data){s().updateNotification(o,{isRead:!0});const n=s();n.stats&&t({stats:u(l({},n.stats),{unread:Math.max(0,n.stats.unread-1)}),unreadCount:Math.max(0,n.unreadCount-1)})}else throw new Error(((r=i.error)==null?void 0:r.message)||"Failed to mark as read")}catch(i){const n=((e=i.error)==null?void 0:e.message)||i.message||"KhÃ´ng thá»ƒ Ä‘Ã¡nh dáº¥u Ä‘Ã£ Ä‘á»c";throw t({error:n,isLoading:!1}),i}finally{t({isLoading:!1})}}),markAllAsRead:()=>f(void 0,null,function*(){var o,r;try{t({isLoading:!0,error:null});const e=yield g.post("/notifications/read-all");if(e.success){t(n=>({notifications:n.notifications.map(a=>u(l({},a),{isRead:!0})),unreadCount:0}));const i=s();i.stats&&t({stats:u(l({},i.stats),{unread:0})})}else throw new Error(((o=e.error)==null?void 0:o.message)||"Failed to mark all as read")}catch(e){const i=((r=e.error)==null?void 0:r.message)||e.message||"KhÃ´ng thá»ƒ Ä‘Ã¡nh dáº¥u táº¥t cáº£ Ä‘Ã£ Ä‘á»c";throw t({error:i,isLoading:!1}),e}finally{t({isLoading:!1})}}),fetchStats:()=>f(void 0,null,function*(){var o,r;try{const e=s();if(e.isStatsLoading)return e.stats;t({isStatsLoading:!0,error:null});const i=yield g.get("/notifications/stats");if(i.success&&i.data)return t({stats:i.data,unreadCount:i.data.unread,error:null}),i.data;throw new Error(((o=i.error)==null?void 0:o.message)||"Failed to fetch stats")}catch(e){const i=((r=e.error)==null?void 0:r.message)||e.message||"KhÃ´ng thá»ƒ táº£i thá»‘ng kÃª";throw t({error:i,isStatsLoading:!1}),e}finally{t({isStatsLoading:!1})}})})),F=()=>h(t=>t.notifications),p=()=>h(t=>t.stats),M=()=>h(t=>t.unreadCount),b=()=>{const t=h();return{setNotifications:t.setNotifications,setStats:t.setStats,addNotification:t.addNotification,updateNotification:t.updateNotification,removeNotification:t.removeNotification,clearError:t.clearError,setError:t.setError,fetchNotifications:t.fetchNotifications,markAsRead:t.markAsRead,markAllAsRead:t.markAllAsRead,fetchStats:t.fetchStats}};export{h as default,b as useNotificationActions,p as useNotificationStats,h as useNotificationStore,F as useNotifications,M as useUnreadCount};
